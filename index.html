<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Mapper - Marin County</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        
        .overlay-controls {
            padding: 15px 20px;
            background: #e8f5e8;
            border-bottom: 1px solid #c3e6c3;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            width: 150px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #51cf66, #40c057);
            color: white;
            box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            transform: translateY(-1px);
        }
        
        #map {
            height: 500px;
            width: 100%;
            border-radius: 0;
        }
        
        .output-section {
            padding: 20px;
            background: white;
        }
        
        .output-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.5em;
            font-weight: 600;
        }
        
        #coordinatesOutput {
            width: 100%;
            height: 200px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #f8f9fa;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        #coordinatesOutput:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .info {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border: 1px solid #2196f3;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #1565c0;
        }
        
        .status {
            text-align: center;
            margin: 15px 0;
            font-weight: 600;
        }
        
        .status.drawing {
            color: #ff6b6b;
        }
        
        .status.ready {
            color: #51cf66;
        }
        
        .status.overlay-edit {
            color: #ff9800;
        }
        
        /* Overlay control handles - Google Earth Pro style */
        .overlay-handle {
            position: absolute;
            background: #fff;
            border: 2px solid #4285f4;
            border-radius: 4px;
            width: 12px;
            height: 12px;
            z-index: 1000;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .overlay-handle.corner {
            cursor: nw-resize;
        }
        
        .overlay-handle.edge-n, .overlay-handle.edge-s {
            cursor: ns-resize;
        }
        
        .overlay-handle.edge-e, .overlay-handle.edge-w {
            cursor: ew-resize;
        }
        
        .overlay-handle.center {
            background: #ff4444;
            border-color: #cc0000;
            cursor: move;
            width: 16px;
            height: 16px;
            border-radius: 8px;
        }
        
        .overlay-handle.rotate {
            background: #00aa00;
            border-color: #008800;
            cursor: alias;
            width: 14px;
            height: 14px;
            border-radius: 7px;
        }
        
        .overlay-outline {
            position: absolute;
            border: 2px dashed #4285f4;
            background: rgba(66, 133, 244, 0.1);
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è Polygon Mapper</h1>
            <p>Draw polygons on Marin County and export coordinates in Y,X format</p>
        </div>
        
        <div class="overlay-controls">
            <div class="file-input-wrapper">
                <input type="file" id="imageUpload" class="file-input" accept="image/*">
                <button class="btn btn-primary">üìÅ Upload Map Overlay</button>
            </div>
            <div class="slider-container">
                <label>Opacity:</label>
                <input type="range" id="opacitySlider" class="slider" min="0" max="100" value="70">
                <span id="opacityValue">70%</span>
            </div>
            <div class="slider-container">
                <label>Rotation:</label>
                <input type="range" id="rotationSlider" class="slider" min="0" max="360" value="0" style="display:none;">
                <span id="rotationValue" style="display:none;">0¬∞</span>
            </div>
            <button id="editOverlayBtn" class="btn btn-primary" style="display:none;">‚úèÔ∏è Edit Overlay</button>
            <button id="toggleOverlay" class="btn btn-primary" style="display:none;">üëÅÔ∏è Toggle Overlay</button>
            <button id="removeOverlay" class="btn btn-danger" style="display:none;">üóëÔ∏è Remove Overlay</button>
        </div>
        
        <div class="controls">
            <button id="drawBtn" class="btn btn-primary">üé® Start Drawing</button>
            <button id="finishBtn" class="btn btn-success" disabled>‚úÖ Finish Polygon</button>
            <button id="clearBtn" class="btn btn-danger">üóëÔ∏è Clear All</button>
            <button id="exportBtn" class="btn btn-primary" disabled>üì§ Generate Coordinates</button>
        </div>
        
        <div class="info">
            <strong>Instructions:</strong> First upload your historical map overlay using the "Upload Map Overlay" button. Click "Edit Overlay" to position, resize, and rotate it using the control handles. Then click "Start Drawing" and click on the map to create polygon vertices following the rancho boundaries. Click "Finish Polygon" to complete each shape. The output will be in Y,X (latitude,longitude) format.
        </div>
        
        <div class="status ready" id="status">Ready to draw</div>
        
        <div id="map"></div>
        
        <div class="output-section">
            <h3>üìÑ Coordinates Output (Y,X format)</h3>
            <textarea id="coordinatesOutput" placeholder="Your coordinates will appear here after drawing polygons and clicking 'Generate Coordinates'..."></textarea>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // Initialize map centered on Marin County, CA
        const map = L.map('map').setView([38.0834, -122.7633], 11);
        
        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
        
        // State management
        let isDrawing = false;
        let isEditingOverlay = false;
        let currentPolygonPoints = [];
        let allPolygons = [];
        let tempMarkers = [];
        let completedPolygonLayers = [];
        let imageOverlay = null;
        let overlayVisible = true;
        let overlayHandles = [];
        let activeHandle = null;
        let dragStartPos = null;
        let overlayRotation = 0;
        let isRotating = false;
        let rotationStartAngle = 0;
        
        // Overlay transform state
        let overlayState = {
            center: null,
            width: 0,
            height: 0,
            rotation: 0,
            bounds: null
        };
        
        // DOM elements
        const drawBtn = document.getElementById('drawBtn');
        const finishBtn = document.getElementById('finishBtn');
        const clearBtn = document.getElementById('clearBtn');
        const exportBtn = document.getElementById('exportBtn');
        const coordinatesOutput = document.getElementById('coordinatesOutput');
        const status = document.getElementById('status');
        const imageUpload = document.getElementById('imageUpload');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValue = document.getElementById('rotationValue');
        const editOverlayBtn = document.getElementById('editOverlayBtn');
        const toggleOverlay = document.getElementById('toggleOverlay');
        const removeOverlay = document.getElementById('removeOverlay');
        
        // Utility functions
        function degreesToRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        function radiansToDegrees(radians) {
            return radians * (180 / Math.PI);
        }
        
        function rotatePoint(point, center, angleRad) {
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            const dx = point.lat - center.lat;
            const dy = point.lng - center.lng;
            return {
                lat: center.lat + dx * cos - dy * sin,
                lng: center.lng + dx * sin + dy * cos
            };
        }
        
        function calculateAngle(center, point) {
            return Math.atan2(point.lng - center.lng, point.lat - center.lat);
        }
        
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.lat - p1.lat, 2) + Math.pow(p2.lng - p1.lng, 2));
        }
        
        // Update status display
        function updateStatus(message, type = 'ready') {
            status.textContent = message;
            status.className = `status ${type}`;
        }
        
        // Calculate rotated corner positions
        function getRotatedCorners(center, width, height, rotation) {
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            const angleRad = degreesToRadians(rotation);
            
            const corners = [
                { lat: -halfHeight, lng: -halfWidth }, // SW
                { lat: -halfHeight, lng: halfWidth },  // SE
                { lat: halfHeight, lng: halfWidth },   // NE
                { lat: halfHeight, lng: -halfWidth }   // NW
            ];
            
            return corners.map(corner => rotatePoint(corner, { lat: 0, lng: 0 }, angleRad))
                         .map(corner => ({ 
                             lat: center.lat + corner.lat, 
                             lng: center.lng + corner.lng 
                         }));
        }
        
        // Update overlay bounds based on current state
        function updateOverlayBounds() {
            if (!imageOverlay || !overlayState.center) return;
            
            const corners = getRotatedCorners(
                overlayState.center,
                overlayState.width,
                overlayState.height,
                overlayState.rotation
            );
            
            // Find the bounding rectangle that contains all rotated corners
            const lats = corners.map(c => c.lat);
            const lngs = corners.map(c => c.lng);
            
            const bounds = [
                [Math.min(...lats), Math.min(...lngs)],
                [Math.max(...lats), Math.max(...lngs)]
            ];
            
            overlayState.bounds = bounds;
            
            // Update the overlay
            const imageUrl = imageOverlay.getElement().src;
            const opacity = imageOverlay.options.opacity;
            map.removeLayer(imageOverlay);
            imageOverlay = L.imageOverlay(imageUrl, bounds, { opacity }).addTo(map);
            
            // Apply CSS rotation
            const element = imageOverlay.getElement();
            if (element) {
                element.style.transformOrigin = '50% 50%';
                element.style.transform = `rotate(${overlayState.rotation}deg)`;
            }
        }
        
        // Create overlay control handles
        function createOverlayHandles() {
            removeOverlayHandles();
            
            if (!imageOverlay || !overlayState.center || !isEditingOverlay) return;
            
            const center = overlayState.center;
            const halfWidth = overlayState.width / 2;
            const halfHeight = overlayState.height / 2;
            const angleRad = degreesToRadians(overlayState.rotation);
            
            // Calculate handle positions (before rotation)
            const handlePositions = {
                'nw': { lat: halfHeight, lng: -halfWidth },
                'ne': { lat: halfHeight, lng: halfWidth },
                'se': { lat: -halfHeight, lng: halfWidth },
                'sw': { lat: -halfHeight, lng: -halfWidth },
                'n': { lat: halfHeight, lng: 0 },
                's': { lat: -halfHeight, lng: 0 },
                'e': { lat: 0, lng: halfWidth },
                'w': { lat: 0, lng: -halfWidth },
                'center': { lat: 0, lng: 0 },
                'rotate': { lat: halfHeight + halfHeight * 0.3, lng: 0 }
            };
            
            // Create handles
            Object.entries(handlePositions).forEach(([id, relPos]) => {
                // Rotate position relative to center
                const rotatedPos = rotatePoint(relPos, { lat: 0, lng: 0 }, angleRad);
                const absolutePos = {
                    lat: center.lat + rotatedPos.lat,
                    lng: center.lng + rotatedPos.lng
                };
                
                const handleType = id === 'center' ? 'center' : 
                                 id === 'rotate' ? 'rotate' :
                                 ['nw', 'ne', 'se', 'sw'].includes(id) ? 'corner' : 'edge';
                
                const handle = L.marker([absolutePos.lat, absolutePos.lng], {
                    icon: L.divIcon({
                        className: `overlay-handle ${handleType}`,
                        iconSize: handleType === 'center' ? [16, 16] : handleType === 'rotate' ? [14, 14] : [12, 12],
                        iconAnchor: handleType === 'center' ? [8, 8] : handleType === 'rotate' ? [7, 7] : [6, 6]
                    }),
                    draggable: true,
                    zIndexOffset: 1000
                });
                
                handle.handleType = handleType;
                handle.handleId = id;
                
                handle.on('dragstart', onHandleDragStart);
                handle.on('drag', onHandleDrag);
                handle.on('dragend', onHandleDragEnd);
                
                handle.addTo(map);
                overlayHandles.push(handle);
            });
        }
        
        function removeOverlayHandles() {
            overlayHandles.forEach(handle => map.removeLayer(handle));
            overlayHandles = [];
        }
        
        function onHandleDragStart(e) {
            activeHandle = e.target;
            dragStartPos = e.target.getLatLng();
            map.dragging.disable();
            
            if (activeHandle.handleType === 'rotate') {
                isRotating = true;
                rotationStartAngle = calculateAngle(overlayState.center, dragStartPos);
            }
        }
        
        function onHandleDrag(e) {
            if (!activeHandle || !overlayState.center) return;
            
            const currentPos = e.target.getLatLng();
            
            if (activeHandle.handleType === 'rotate') {
                // Handle rotation
                const currentAngle = calculateAngle(overlayState.center, currentPos);
                const deltaAngle = radiansToDegrees(currentAngle - rotationStartAngle);
                overlayState.rotation = (overlayState.rotation + deltaAngle) % 360;
                if (overlayState.rotation < 0) overlayState.rotation += 360;
                
                rotationSlider.value = overlayState.rotation;
                rotationValue.textContent = Math.round(overlayState.rotation) + '¬∞';
                
                updateOverlayBounds();
                createOverlayHandles(); // Recreate handles with new rotation
                rotationStartAngle = currentAngle;
                return;
            }
            
            const deltaLat = currentPos.lat - dragStartPos.lat;
            const deltaLng = currentPos.lng - dragStartPos.lng;
            
            if (activeHandle.handleType === 'center') {
                // Move the entire overlay
                overlayState.center.lat += deltaLat;
                overlayState.center.lng += deltaLng;
                updateOverlayBounds();
                createOverlayHandles();
            } else if (activeHandle.handleType === 'corner' || activeHandle.handleType === 'edge') {
                // Handle resizing
                const center = overlayState.center;
                
                // Convert drag vector to local coordinate system (accounting for rotation)
                const angleRad = degreesToRadians(-overlayState.rotation);
                const localDelta = rotatePoint({ lat: deltaLat, lng: deltaLng }, { lat: 0, lng: 0 }, angleRad);
                
                let newWidth = overlayState.width;
                let newHeight = overlayState.height;
                let centerOffset = { lat: 0, lng: 0 };
                
                switch (activeHandle.handleId) {
                    case 'nw':
                        newWidth -= localDelta.lng * 2;
                        newHeight += localDelta.lat * 2;
                        centerOffset.lng = -localDelta.lng / 2;
                        centerOffset.lat = localDelta.lat / 2;
                        break;
                    case 'ne':
                        newWidth += localDelta.lng * 2;
                        newHeight += localDelta.lat * 2;
                        centerOffset.lng = localDelta.lng / 2;
                        centerOffset.lat = localDelta.lat / 2;
                        break;
                    case 'se':
                        newWidth += localDelta.lng * 2;
                        newHeight -= localDelta.lat * 2;
                        centerOffset.lng = localDelta.lng / 2;
                        centerOffset.lat = -localDelta.lat / 2;
                        break;
                    case 'sw':
                        newWidth -= localDelta.lng * 2;
                        newHeight -= localDelta.lat * 2;
                        centerOffset.lng = -localDelta.lng / 2;
                        centerOffset.lat = -localDelta.lat / 2;
                        break;
                    case 'n':
                        newHeight += localDelta.lat * 2;
                        centerOffset.lat = localDelta.lat / 2;
                        break;
                    case 's':
                        newHeight -= localDelta.lat * 2;
                        centerOffset.lat = -localDelta.lat / 2;
                        break;
                    case 'e':
                        newWidth += localDelta.lng * 2;
                        centerOffset.lng = localDelta.lng / 2;
                        break;
                    case 'w':
                        newWidth -= localDelta.lng * 2;
                        centerOffset.lng = -localDelta.lng / 2;
                        break;
                }
                
                // Ensure minimum size
                if (newWidth > 0.001 && newHeight > 0.001) {
                    overlayState.width = newWidth;
                    overlayState.height = newHeight;
                    
                    // Apply center offset in world coordinates
                    const worldOffset = rotatePoint(centerOffset, { lat: 0, lng: 0 }, degreesToRadians(overlayState.rotation));
                    overlayState.center.lat += worldOffset.lat;
                    overlayState.center.lng += worldOffset.lng;
                    
                    updateOverlayBounds();
                    createOverlayHandles();
                }
            }
            
            dragStartPos = currentPos;
        }
        
        function onHandleDragEnd(e) {
            activeHandle = null;
            dragStartPos = null;
            isRotating = false;
            map.dragging.enable();
        }
        
        // Toggle overlay editing mode
        function toggleOverlayEditMode(enable) {
            isEditingOverlay = enable;
            
            if (enable) {
                editOverlayBtn.textContent = '‚úÖ Done Editing';
                editOverlayBtn.classList.add('active');
                createOverlayHandles();
                updateStatus('Drag handles to resize/move. Use green handle to rotate. Click "Done Editing" when finished.', 'overlay-edit');
                map.off('click', handleMapClick);
            } else {
                editOverlayBtn.textContent = '‚úèÔ∏è Edit Overlay';
                editOverlayBtn.classList.remove('active');
                removeOverlayHandles();
                updateStatus('Overlay editing completed. Ready to draw polygons.', 'ready');
                map.on('click', handleMapClick);
            }
        }
        
        // Handle image upload
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    // Remove existing overlay
                    if (imageOverlay) {
                        map.removeLayer(imageOverlay);
                    }
                    
                    // Define default bounds and state for Marin County
                    const marinBounds = [[37.8, -123.2], [38.4, -122.3]];
                    
                    overlayState = {
                        center: { lat: (37.8 + 38.4) / 2, lng: (-123.2 + -122.3) / 2 },
                        width: -122.3 - (-123.2),
                        height: 38.4 - 37.8,
                        rotation: 0,
                        bounds: marinBounds
                    };
                    
                    // Add image overlay
                    imageOverlay = L.imageOverlay(event.target.result, marinBounds, {
                        opacity: opacitySlider.value / 100
                    }).addTo(map);
                    
                    // Show overlay controls
                    editOverlayBtn.style.display = 'inline-block';
                    toggleOverlay.style.display = 'inline-block';
                    removeOverlay.style.display = 'inline-block';
                    rotationSlider.style.display = 'inline-block';
                    rotationValue.style.display = 'inline-block';
                    overlayVisible = true;
                    
                    // Reset sliders
                    rotationSlider.value = 0;
                    rotationValue.textContent = '0¬∞';
                    
                    updateStatus('Map overlay added! Click "Edit Overlay" to position and rotate it correctly.', 'ready');
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Handle opacity changes
        opacitySlider.addEventListener('input', (e) => {
            const value = e.target.value;
            opacityValue.textContent = value + '%';
            if (imageOverlay) {
                imageOverlay.setOpacity(value / 100);
            }
        });
        
        // Handle rotation changes from slider
        rotationSlider.addEventListener('input', (e) => {
            overlayState.rotation = parseFloat(e.target.value);
            rotationValue.textContent = Math.round(overlayState.rotation) + '¬∞';
            updateOverlayBounds();
            if (isEditingOverlay) {
                createOverlayHandles();
            }
        });
        
        // Edit overlay button
        editOverlayBtn.addEventListener('click', () => {
            toggleOverlayEditMode(!isEditingOverlay);
        });
        
        // Toggle overlay visibility
        toggleOverlay.addEventListener('click', () => {
            if (imageOverlay) {
                if (overlayVisible) {
                    map.removeLayer(imageOverlay);
                    removeOverlayHandles();
                    toggleOverlay.textContent = 'üëÅÔ∏è Show Overlay';
                    overlayVisible = false;
                } else {
                    imageOverlay.addTo(map);
                    updateOverlayBounds(); // Reapply transform
                    if (isEditingOverlay) createOverlayHandles();
                    toggleOverlay.textContent = 'üëÅÔ∏è Hide Overlay';
                    overlayVisible = true;
                }
            }
        });
        
        // Remove overlay
        removeOverlay.addEventListener('click', () => {
            if (imageOverlay) {
                map.removeLayer(imageOverlay);
                removeOverlayHandles();
                imageOverlay = null;
                overlayState = { center: null, width: 0, height: 0, rotation: 0, bounds: null };
                editOverlayBtn.style.display = 'none';
                toggleOverlay.style.display = 'none';
                removeOverlay.style.display = 'none';
                rotationSlider.style.display = 'none';
                rotationValue.style.display = 'none';
                isEditingOverlay = false;
                updateStatus('Map overlay removed', 'ready');
            }
        });
        
        // Drawing functionality
        function handleMapClick(e) {
            if (!isDrawing || isEditingOverlay) return;
            
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            
            currentPolygonPoints.push([lat, lng]);
            
            // Add temporary marker
            const marker = L.circleMarker([lat, lng], {
                color: '#ff6b6b',
                fillColor: '#ff6b6b',
                fillOpacity: 1,
                radius: 5
            }).addTo(map);
            
            tempMarkers.push(marker);
            
            // Update finish button state
            finishBtn.disabled = currentPolygonPoints.length < 3;
            
            updateStatus(`${currentPolygonPoints.length} points added. ${currentPolygonPoints.length < 3 ? 'Need at least 3 points.' : 'Ready to finish polygon.'}`, 'drawing');
        }
        
        // Start drawing mode
        drawBtn.addEventListener('click', () => {
            if (!isDrawing) {
                isDrawing = true;
                currentPolygonPoints = [];
                drawBtn.textContent = '‚è∏Ô∏è Stop Drawing';
                finishBtn.disabled = true;
                updateStatus('Click on the map to add polygon points', 'drawing');
                map.getContainer().style.cursor = 'crosshair';
            } else {
                stopDrawing();
            }
        });
        
        // Stop drawing mode
        function stopDrawing() {
            isDrawing = false;
            drawBtn.textContent = 'üé® Start Drawing';
            finishBtn.disabled = currentPolygonPoints.length < 3;
            map.getContainer().style.cursor = '';
            
            if (currentPolygonPoints.length > 0) {
                updateStatus(`${currentPolygonPoints.length} points added. Click "Finish Polygon" to complete.`, 'drawing');
            } else {
                updateStatus('Ready to draw', 'ready');
            }
        }
        
        // Finish current polygon
        finishBtn.addEventListener('click', () => {
            if (currentPolygonPoints.length >= 3) {
                // Create polygon layer
                const polygon = L.polygon(currentPolygonPoints, {
                    color: '#667eea',
                    fillColor: '#667eea',
                    fillOpacity: 0.3,
                    weight: 3
                }).addTo(map);
                
                completedPolygonLayers.push(polygon);
                
                // Store polygon data
                allPolygons.push([...currentPolygonPoints]);
                
                // Clear temporary markers
                tempMarkers.forEach(marker => map.removeLayer(marker));
                tempMarkers = [];
                
                // Reset state
                currentPolygonPoints = [];
                finishBtn.disabled = true;
                exportBtn.disabled = false;
                
                updateStatus(`Polygon completed! Total polygons: ${allPolygons.length}`, 'ready');
            }
        });
        
        // Clear all polygons
        clearBtn.addEventListener('click', () => {
            // Remove all polygon layers
            completedPolygonLayers.forEach(layer => map.removeLayer(layer));
            completedPolygonLayers = [];
            
            // Remove temporary markers
            tempMarkers.forEach(marker => map.removeLayer(marker));
            tempMarkers = [];
            
            // Reset state
            allPolygons = [];
            currentPolygonPoints = [];
            isDrawing = false;
            
            // Reset buttons
            drawBtn.textContent = 'üé® Start Drawing';
            finishBtn.disabled = true;
            exportBtn.disabled = true;
            
            // Clear output
            coordinatesOutput.value = '';
            
            map.getContainer().style.cursor = '';
            updateStatus('All polygons cleared. Ready to draw', 'ready');
        });
        
        // Generate coordinates in Y,X format
        exportBtn.addEventListener('click', () => {
            if (allPolygons.length === 0) return;
            
            let output = 'coordinates: [\n';
            
            allPolygons.forEach((polygon, index) => {
                output += '    [';
                
                // Add coordinates in Y,X format (latitude, longitude)
                polygon.forEach((point, pointIndex) => {
                    output += `[${point[0]},${point[1]}]`;
                    if (pointIndex < polygon.length - 1) {
                        output += ',\n                    ';
                    }
                });
                
                output += ']';
                if (index < allPolygons.length - 1) {
                    output += ',\n';
                }
                output += '\n';
            });
            
            output += ']';
            
            coordinatesOutput.value = output;
            coordinatesOutput.select();
            updateStatus(`Coordinates generated for ${allPolygons.length} polygon(s) in Y,X format. Text selected for copying.`, 'ready');
        });
        
        // Initialize map click handler
        map.on('click', handleMapClick);
    </script>
</body>
</html>
