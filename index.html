<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Mapper - Marin County</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        
        .overlay-controls {
            padding: 15px 20px;
            background: #e8f5e8;
            border-bottom: 1px solid #c3e6c3;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            width: 150px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #51cf66, #40c057);
            color: white;
            box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            transform: translateY(-1px);
        }
        
        #map {
            height: 500px;
            width: 100%;
            border-radius: 0;
        }
        
        .output-section {
            padding: 20px;
            background: white;
        }
        
        .output-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.5em;
            font-weight: 600;
        }
        
        #coordinatesOutput {
            width: 100%;
            height: 200px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #f8f9fa;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        #coordinatesOutput:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .info {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border: 1px solid #2196f3;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #1565c0;
        }
        
        .status {
            text-align: center;
            margin: 15px 0;
            font-weight: 600;
        }
        
        .status.drawing {
            color: #ff6b6b;
        }
        
        .status.ready {
            color: #51cf66;
        }
        
        .status.overlay-edit {
            color: #ff9800;
        }
        
        /* Overlay control handles - Google Earth Pro style */
        .overlay-handle {
            position: absolute;
            background: #fff;
            border: 2px solid #4285f4;
            border-radius: 4px;
            width: 12px;
            height: 12px;
            z-index: 1000;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .overlay-handle.corner {
            cursor: nw-resize;
        }
        
        .overlay-handle.edge-n, .overlay-handle.edge-s {
            cursor: ns-resize;
        }
        
        .overlay-handle.edge-e, .overlay-handle.edge-w {
            cursor: ew-resize;
        }
        
        .overlay-handle.center {
            background: #ff4444;
            border-color: #cc0000;
            cursor: move;
            width: 16px;
            height: 16px;
            border-radius: 8px;
        }
        
        .overlay-handle.rotate {
            background: #00aa00;
            border-color: #008800;
            cursor: alias;
            width: 14px;
            height: 14px;
            border-radius: 7px;
        }
        
        .overlay-outline {
            position: absolute;
            border: 2px dashed #4285f4;
            background: rgba(66, 133, 244, 0.1);
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è Polygon Mapper</h1>
            <p>Draw polygons on Marin County and export coordinates in Y,X format</p>
        </div>
        
        <div class="overlay-controls">
            <div class="file-input-wrapper">
                <input type="file" id="imageUpload" class="file-input" accept="image/*">
                <button class="btn btn-primary">üìÅ Upload Map Overlay</button>
            </div>
            <div class="slider-container">
                <label>Opacity:</label>
                <input type="range" id="opacitySlider" class="slider" min="0" max="100" value="70">
                <span id="opacityValue">70%</span>
            </div>
            <div class="slider-container">
                <label>Rotation:</label>
                <input type="range" id="rotationSlider" class="slider" min="0" max="360" value="0" style="display:none;">
                <span id="rotationValue" style="display:none;">0¬∞</span>
            </div>
            <button id="editOverlayBtn" class="btn btn-primary" style="display:none;">‚úèÔ∏è Edit Overlay</button>
            <button id="toggleOverlay" class="btn btn-primary" style="display:none;">üëÅÔ∏è Toggle Overlay</button>
            <button id="removeOverlay" class="btn btn-danger" style="display:none;">üóëÔ∏è Remove Overlay</button>
        </div>
        
        <div class="controls">
            <button id="drawBtn" class="btn btn-primary">üé® Start Drawing</button>
            <button id="finishBtn" class="btn btn-success" disabled>‚úÖ Finish Polygon</button>
            <button id="clearBtn" class="btn btn-danger">üóëÔ∏è Clear All</button>
            <button id="exportBtn" class="btn btn-primary" disabled>üì§ Generate Coordinates</button>
        </div>
        
        <div class="info">
            <strong>Instructions:</strong> First upload your historical map overlay using the "Upload Map Overlay" button. Click "Edit Overlay" to position, resize, and rotate it using the control handles. Then click "Start Drawing" and click on the map to create polygon vertices following the rancho boundaries. Click "Finish Polygon" to complete each shape. The output will be in Y,X (latitude,longitude) format.
        </div>
        
        <div class="status ready" id="status">Ready to draw</div>
        
        <div id="map"></div>
        
        <div class="output-section">
            <h3>üìÑ Coordinates Output (Y,X format)</h3>
            <textarea id="coordinatesOutput" placeholder="Your coordinates will appear here after drawing polygons and clicking 'Generate Coordinates'..."></textarea>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // Initialize map centered on Marin County, CA
        const map = L.map('map').setView([38.0834, -122.7633], 11);
        
        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
        
        // State management
        let isDrawing = false;
        let isEditingOverlay = false;
        let currentPolygonPoints = [];
        let allPolygons = [];
        let tempMarkers = [];
        let completedPolygonLayers = [];
        let imageOverlay = null;
        let overlayVisible = true;
        let currentBounds = null;
        let overlayHandles = [];
        let activeHandle = null;
        let dragStartPos = null;
        let initialBounds = null;
        let overlayRotation = 0;
        let overlayCenter = null;
        let isRotating = false;
        let rotationStartAngle = 0;
        
        // DOM elements
        const drawBtn = document.getElementById('drawBtn');
        const finishBtn = document.getElementById('finishBtn');
        const clearBtn = document.getElementById('clearBtn');
        const exportBtn = document.getElementById('exportBtn');
        const coordinatesOutput = document.getElementById('coordinatesOutput');
        const status = document.getElementById('status');
        const imageUpload = document.getElementById('imageUpload');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValue = document.getElementById('rotationValue');
        const editOverlayBtn = document.getElementById('editOverlayBtn');
        const toggleOverlay = document.getElementById('toggleOverlay');
        const removeOverlay = document.getElementById('removeOverlay');
        
        // Utility functions
        function degreesToRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        function radiansToDegrees(radians) {
            return radians * (180 / Math.PI);
        }
        
        function rotatePoint(point, center, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const dx = point[0] - center[0];
            const dy = point[1] - center[1];
            return [
                center[0] + dx * cos - dy * sin,
                center[1] + dx * sin + dy * cos
            ];
        }
        
        function calculateAngle(center, point) {
            return Math.atan2(point[1] - center[1], point[0] - center[0]);
        }
        
        // Update status display
        function updateStatus(message, type = 'ready') {
            status.textContent = message;
            status.className = `status ${type}`;
        }
        
        // Apply rotation to overlay
        function applyRotationToOverlay() {
            if (!imageOverlay || !overlayCenter) return;
            
            const element = imageOverlay.getElement();
            if (element) {
                element.style.transformOrigin = '50% 50%';
                element.style.transform = `rotate(${overlayRotation}deg)`;
            }
        }
        
        // Create overlay control handles (Google Earth Pro style + rotation)
        function createOverlayHandles() {
            removeOverlayHandles();
            
            if (!imageOverlay || !currentBounds || !isEditingOverlay) return;
            
            const bounds = imageOverlay.getBounds();
            const north = bounds.getNorth();
            const south = bounds.getSouth();
            const east = bounds.getEast();
            const west = bounds.getWest();
            const centerLat = (north + south) / 2;
            const centerLng = (east + west) / 2;
            
            overlayCenter = [centerLat, centerLng];
            
            // Create 8 resize handles + 1 center handle + 1 rotation handle
            const handles = [
                // Corners
                { pos: [north, west], type: 'corner', cursor: 'nw-resize', id: 'nw' },
                { pos: [north, east], type: 'corner', cursor: 'ne-resize', id: 'ne' },
                { pos: [south, east], type: 'corner', cursor: 'se-resize', id: 'se' },
                { pos: [south, west], type: 'corner', cursor: 'sw-resize', id: 'sw' },
                // Edges
                { pos: [north, centerLng], type: 'edge', cursor: 'n-resize', id: 'n' },
                { pos: [south, centerLng], type: 'edge', cursor: 'n-resize', id: 's' },
                { pos: [centerLat, east], type: 'edge', cursor: 'e-resize', id: 'e' },
                { pos: [centerLat, west], type: 'edge', cursor: 'e-resize', id: 'w' },
                // Center (move handle)
                { pos: [centerLat, centerLng], type: 'center', cursor: 'move', id: 'center' },
                // Rotation handle (above center)
                { pos: [north + (north - south) * 0.2, centerLng], type: 'rotate', cursor: 'alias', id: 'rotate' }
            ];
            
            handles.forEach(handleData => {
                const handle = L.marker(handleData.pos, {
                    icon: L.divIcon({
                        className: `overlay-handle ${handleData.type}`,
                        iconSize: handleData.type === 'center' ? [16, 16] : handleData.type === 'rotate' ? [14, 14] : [12, 12],
                        iconAnchor: handleData.type === 'center' ? [8, 8] : handleData.type === 'rotate' ? [7, 7] : [6, 6]
                    }),
                    draggable: true,
                    zIndexOffset: 1000
                });
                
                handle.handleType = handleData.type;
                handle.handleId = handleData.id;
                
                handle.on('dragstart', onHandleDragStart);
                handle.on('drag', onHandleDrag);
                handle.on('dragend', onHandleDragEnd);
                
                handle.addTo(map);
                overlayHandles.push(handle);
            });
        }
        
        function removeOverlayHandles() {
            overlayHandles.forEach(handle => map.removeLayer(handle));
            overlayHandles = [];
        }
        
        function onHandleDragStart(e) {
            activeHandle = e.target;
            dragStartPos = e.target.getLatLng();
            initialBounds = imageOverlay.getBounds();
            map.dragging.disable();
            
            if (activeHandle.handleType === 'rotate') {
                isRotating = true;
                rotationStartAngle = calculateAngle(overlayCenter, [dragStartPos.lat, dragStartPos.lng]);
            }
        }
        
        function onHandleDrag(e) {
            if (!activeHandle || !initialBounds) return;
            
            const currentPos = e.target.getLatLng();
            
            if (activeHandle.handleType === 'rotate') {
                // Handle rotation
                const currentAngle = calculateAngle(overlayCenter, [currentPos.lat, currentPos.lng]);
                const deltaAngle = radiansToDegrees(currentAngle - rotationStartAngle);
                overlayRotation = (overlayRotation + deltaAngle) % 360;
                if (overlayRotation < 0) overlayRotation += 360;
                
                rotationSlider.value = overlayRotation;
                rotationValue.textContent = Math.round(overlayRotation) + '¬∞';
                
                applyRotationToOverlay();
                rotationStartAngle = currentAngle;
                return;
            }
            
            const deltaLat = currentPos.lat - dragStartPos.lat;
            const deltaLng = currentPos.lng - dragStartPos.lng;
            
            let north = initialBounds.getNorth();
            let south = initialBounds.getSouth();
            let east = initialBounds.getEast();
            let west = initialBounds.getWest();
            
            if (activeHandle.handleType === 'center') {
                // Move the entire overlay
                north += deltaLat;
                south += deltaLat;
                east += deltaLng;
                west += deltaLng;
                overlayCenter = [(north + south) / 2, (east + west) / 2];
            } else if (activeHandle.handleType === 'corner') {
                // Resize from corner
                switch (activeHandle.handleId) {
                    case 'nw':
                        north += deltaLat;
                        west += deltaLng;
                        break;
                    case 'ne':
                        north += deltaLat;
                        east += deltaLng;
                        break;
                    case 'se':
                        south += deltaLat;
                        east += deltaLng;
                        break;
                    case 'sw':
                        south += deltaLat;
                        west += deltaLng;
                        break;
                }
                overlayCenter = [(north + south) / 2, (east + west) / 2];
            } else if (activeHandle.handleType === 'edge') {
                // Resize from edge
                switch (activeHandle.handleId) {
                    case 'n':
                        north += deltaLat;
                        break;
                    case 's':
                        south += deltaLat;
                        break;
                    case 'e':
                        east += deltaLng;
                        break;
                    case 'w':
                        west += deltaLng;
                        break;
                }
                overlayCenter = [(north + south) / 2, (east + west) / 2];
            }
            
            // Ensure valid bounds (prevent inside-out rectangles)
            if (north > south && east > west) {
                const newBounds = [[south, west], [north, east]];
                currentBounds = newBounds;
                
                // Update overlay
                const imageUrl = imageOverlay.getElement().src;
                const opacity = imageOverlay.options.opacity;
                map.removeLayer(imageOverlay);
                imageOverlay = L.imageOverlay(imageUrl, newBounds, { opacity }).addTo(map);
                
                // Reapply rotation
                applyRotationToOverlay();
                
                // Update handles to match new bounds
                updateHandlePositions();
            }
        }
        
        function onHandleDragEnd(e) {
            activeHandle = null;
            dragStartPos = null;
            initialBounds = null;
            isRotating = false;
            map.dragging.enable();
        }
        
        function updateHandlePositions() {
            if (!imageOverlay || overlayHandles.length === 0) return;
            
            const bounds = imageOverlay.getBounds();
            const north = bounds.getNorth();
            const south = bounds.getSouth();
            const east = bounds.getEast();
            const west = bounds.getWest();
            const centerLat = (north + south) / 2;
            const centerLng = (east + west) / 2;
            
            const positions = {
                'nw': [north, west],
                'ne': [north, east],
                'se': [south, east],
                'sw': [south, west],
                'n': [north, centerLng],
                's': [south, centerLng],
                'e': [centerLat, east],
                'w': [centerLat, west],
                'center': [centerLat, centerLng],
                'rotate': [north + (north - south) * 0.2, centerLng]
            };
            
            overlayHandles.forEach(handle => {
                if (positions[handle.handleId]) {
                    handle.setLatLng(positions[handle.handleId]);
                }
            });
        }
        
        // Toggle overlay editing mode
        function toggleOverlayEditMode(enable) {
            isEditingOverlay = enable;
            
            if (enable) {
                editOverlayBtn.textContent = '‚úÖ Done Editing';
                editOverlayBtn.classList.add('active');
                createOverlayHandles();
                updateStatus('Drag handles to resize/move. Use green handle to rotate. Click "Done Editing" when finished.', 'overlay-edit');
                // Disable map clicking for polygons
                map.off('click', handleMapClick);
            } else {
                editOverlayBtn.textContent = '‚úèÔ∏è Edit Overlay';
                editOverlayBtn.classList.remove('active');
                removeOverlayHandles();
                updateStatus('Overlay editing completed. Ready to draw polygons.', 'ready');
                // Re-enable map clicking for polygons
                map.on('click', handleMapClick);
            }
        }
        
        // Handle image upload
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    // Remove existing overlay
                    if (imageOverlay) {
                        map.removeLayer(imageOverlay);
                    }
                    
                    // Define default bounds for Marin County
                    const marinBounds = [[37.8, -123.2], [38.4, -122.3]];
                    currentBounds = marinBounds;
                    overlayRotation = 0;
                    
                    // Add image overlay
                    imageOverlay = L.imageOverlay(event.target.result, marinBounds, {
                        opacity: opacitySlider.value / 100
                    }).addTo(map);
                    
                    // Set overlay center
                    overlayCenter = [(37.8 + 38.4) / 2, (-123.2 + -122.3) / 2];
                    
                    // Show overlay controls
                    editOverlayBtn.style.display = 'inline-block';
                    toggleOverlay.style.display = 'inline-block';
                    removeOverlay.style.display = 'inline-block';
                    rotationSlider.style.display = 'inline-block';
                    rotationValue.style.display = 'inline-block';
                    overlayVisible = true;
                    
                    // Reset sliders
                    rotationSlider.value = 0;
                    rotationValue.textContent = '0¬∞';
                    
                    updateStatus('Map overlay added! Click "Edit Overlay" to position and rotate it correctly.', 'ready');
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Handle opacity changes
        opacitySlider.addEventListener('input', (e) => {
            const value = e.target.value;
            opacityValue.textContent = value + '%';
            if (imageOverlay) {
                imageOverlay.setOpacity(value / 100);
            }
        });
        
        // Handle rotation changes
        rotationSlider.addEventListener('input', (e) => {
            overlayRotation = parseFloat(e.target.value);
            rotationValue.textContent = Math.round(overlayRotation) + '¬∞';
            applyRotationToOverlay();
        });
        
        // Edit overlay button
        editOverlayBtn.addEventListener('click', () => {
            toggleOverlayEditMode(!isEditingOverlay);
        });
        
        // Toggle overlay visibility
        toggleOverlay.addEventListener('click', () => {
            if (imageOverlay) {
                if (overlayVisible) {
                    map.removeLayer(imageOverlay);
                    removeOverlayHandles();
                    toggleOverlay.textContent = 'üëÅÔ∏è Show Overlay';
                    overlayVisible = false;
                } else {
                    imageOverlay.addTo(map);
                    applyRotationToOverlay();
                    if (isEditingOverlay) createOverlayHandles();
                    toggleOverlay.textContent = 'üëÅÔ∏è Hide Overlay';
                    overlayVisible = true;
                }
            }
        });
        
        // Remove overlay
        removeOverlay.addEventListener('click', () => {
            if (imageOverlay) {
                map.removeLayer(imageOverlay);
                removeOverlayHandles();
                imageOverlay = null;
                currentBounds = null;
                overlayCenter = null;
                overlayRotation = 0;
                editOverlayBtn.style.display = 'none';
                toggleOverlay.style.display = 'none';
                removeOverlay.style.display = 'none';
                rotationSlider.style.display = 'none';
                rotationValue.style.display = 'none';
                isEditingOverlay = false;
                updateStatus('Map overlay removed', 'ready');
            }
        });
        
        // Drawing functionality
        function handleMapClick(e) {
            if (!isDrawing || isEditingOverlay) return;
            
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            
            currentPolygonPoints.push([lat, lng]);
            
            // Add temporary marker
            const marker = L.circleMarker([lat, lng], {
                color: '#ff6b6b',
                fillColor: '#ff6b6b',
                fillOpacity: 1,
                radius: 5
            }).addTo(map);
            
            tempMarkers.push(marker);
            
            // Update finish button state
            finishBtn.disabled = currentPolygonPoints.length < 3;
            
            updateStatus(`${currentPolygonPoints.length} points added. ${currentPolygonPoints.length < 3 ? 'Need at least 3 points.' : 'Ready to finish polygon.'}`, 'drawing');
        }
        
        // Start drawing mode
        drawBtn.addEventListener('click', () => {
            if (!isDrawing) {
                isDrawing = true;
                currentPolygonPoints = [];
                drawBtn.textContent = '‚è∏Ô∏è Stop Drawing';
                finishBtn.disabled = true;
                updateStatus('Click on the map to add polygon points', 'drawing');
                map.getContainer().style.cursor = 'crosshair';
            } else {
                stopDrawing();
            }
        });
        
        // Stop drawing mode
        function stopDrawing() {
            isDrawing = false;
            drawBtn.textContent = 'üé® Start Drawing';
            finishBtn.disabled = currentPolygonPoints.length < 3;
            map.getContainer().style.cursor = '';
            
            if (currentPolygonPoints.length > 0) {
                updateStatus(`${currentPolygonPoints.length} points added. Click "Finish Polygon" to complete.`, 'drawing');
            } else {
                updateStatus('Ready to draw', 'ready');
            }
        }
        
        // Finish current polygon
        finishBtn.addEventListener('click', () => {
            if (currentPolygonPoints.length >= 3) {
                // Create polygon layer
                const polygon = L.polygon(currentPolygonPoints, {
                    color: '#667eea',
                    fillColor: '#667eea',
                    fillOpacity: 0.3,
                    weight: 3
                }).addTo(map);
                
                completedPolygonLayers.push(polygon);
                
                // Store polygon data
                allPolygons.push([...currentPolygonPoints]);
                
                // Clear temporary markers
                tempMarkers.forEach(marker => map.removeLayer(marker));
                tempMarkers
