<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Polygon to GeoJSON Mapper - Marin County</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .header {
      background: linear-gradient(135deg, #2c3e50, #3498db);
      color: white;
      padding: 20px;
      text-align: center;
    }
    .controls, .overlay-controls {
      padding: 15px 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }
    #map { height: 500px; width: 100%; }
    .btn {
      padding: 10px 20px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      font-weight: 600;
    }
    .btn-primary { background: #667eea; color: white; }
    .btn-success { background: #40c057; color: white; }
    .btn-danger { background: #ee5a52; color: white; }
    .output-section { padding: 20px; }
    #kmlOutput {
      width: 100%;
      height: 200px;
      font-family: monospace;
      font-size: 12px;
    }
    /* Overlay handles */
    .overlay-handle {
      position: absolute;
      background: #fff;
      border: 2px solid #4285f4;
      border-radius: 4px;
      width: 12px;
      height: 12px;
      z-index: 1000;
    }
    .overlay-handle.corner { cursor: nw-resize; }
    .overlay-handle.edge-n, .overlay-handle.edge-s { cursor: ns-resize; }
    .overlay-handle.edge-e, .overlay-handle.edge-w { cursor: ew-resize; }
    .overlay-handle.center {
      background: #ff4444;
      border-color: #cc0000;
      cursor: move;
      width: 16px;
      height: 16px;
      border-radius: 8px;
    }
    .overlay-handle.rotate {
      background: #ffa500;
      border-color: #cc8400;
      cursor: grab;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>ğŸ—ºï¸ Polygon to GeoJSON Mapper</h1>
    <p>Draw polygons on Marin County and export as GeoJSON</p>
  </div>

  <div class="overlay-controls">
    <input type="file" id="imageUpload" accept="image/*">
    <label>Opacity: <input type="range" id="opacitySlider" min="0" max="100" value="70"></label>
    <button id="editOverlayBtn" class="btn btn-primary" style="display:none;">âœï¸ Edit Overlay</button>
    <button id="toggleOverlay" class="btn btn-primary" style="display:none;">ğŸ‘ï¸ Toggle Overlay</button>
    <button id="removeOverlay" class="btn btn-danger" style="display:none;">ğŸ—‘ï¸ Remove Overlay</button>
  </div>

  <div class="controls">
    <button id="drawBtn" class="btn btn-primary">ğŸ¨ Start Drawing</button>
    <button id="finishBtn" class="btn btn-success" disabled>âœ… Finish Polygon</button>
    <button id="clearBtn" class="btn btn-danger">ğŸ—‘ï¸ Clear All</button>
    <button id="exportBtn" class="btn btn-primary" disabled>ğŸ“¥ Generate GeoJSON</button>
  </div>

  <div id="map"></div>

  <div class="output-section">
    <h3>ğŸ“„ GeoJSON Output</h3>
    <textarea id="kmlOutput" placeholder="Your GeoJSON will appear here..."></textarea>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
<script>
  // Init map
  const map = L.map('map').setView([38.0834, -122.7633], 11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap'
  }).addTo(map);

  // State
  let isDrawing = false;
  let currentPolygonPoints = [];
  let allPolygons = [];
  let tempMarkers = [];
  let completedPolygonLayers = [];
  let imageOverlay = null;
  let overlayVisible = true;
  let isEditingOverlay = false;
  let overlayHandles = [];
  let activeHandle = null;
  let dragStartPos = null;
  let initialBounds = null;
  let overlayRotation = 0;

  // DOM
  const drawBtn = document.getElementById('drawBtn');
  const finishBtn = document.getElementById('finishBtn');
  const clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn');
  const kmlOutput = document.getElementById('kmlOutput');
  const imageUpload = document.getElementById('imageUpload');
  const opacitySlider = document.getElementById('opacitySlider');
  const editOverlayBtn = document.getElementById('editOverlayBtn');
  const toggleOverlay = document.getElementById('toggleOverlay');
  const removeOverlay = document.getElementById('removeOverlay');

  function updateStatus(msg) { console.log(msg); }

  // Overlay handles
  function createOverlayHandles() {
    removeOverlayHandles();
    if (!imageOverlay || !isEditingOverlay) return;
    const bounds = imageOverlay.getBounds();
    const north = bounds.getNorth();
    const south = bounds.getSouth();
    const east = bounds.getEast();
    const west = bounds.getWest();
    const centerLat = (north + south) / 2;
    const centerLng = (east + west) / 2;

    const handles = [
      { pos: [north, west], type: 'corner', id: 'nw' },
      { pos: [north, east], type: 'corner', id: 'ne' },
      { pos: [south, east], type: 'corner', id: 'se' },
      { pos: [south, west], type: 'corner', id: 'sw' },
      { pos: [north, centerLng], type: 'edge', id: 'n' },
      { pos: [south, centerLng], type: 'edge', id: 's' },
      { pos: [centerLat, east], type: 'edge', id: 'e' },
      { pos: [centerLat, west], type: 'edge', id: 'w' },
      { pos: [centerLat, centerLng], type: 'center', id: 'center' },
      { pos: [north + (north - south) * 0.1, centerLng], type: 'rotate', id: 'rotate' }
    ];

    handles.forEach(h => {
      const handle = L.marker(h.pos, {
        icon: L.divIcon({
          className: `overlay-handle ${h.type}`,
          iconSize: h.type === 'center' ? [16, 16] : [12, 12],
          iconAnchor: h.type === 'center' ? [8, 8] : [6, 6]
        }),
        draggable: true,
        zIndexOffset: 1000
      });
      handle.handleType = h.type;
      handle.handleId = h.id;
      handle.on('dragstart', onHandleDragStart);
      handle.on('drag', onHandleDrag);
      handle.on('dragend', onHandleDragEnd);
      handle.addTo(map);
      overlayHandles.push(handle);
    });
  }

  function removeOverlayHandles() {
    overlayHandles.forEach(h => map.removeLayer(h));
    overlayHandles = [];
  }

  function onHandleDragStart(e) {
    activeHandle = e.target;
    dragStartPos = e.target.getLatLng();
    initialBounds = imageOverlay.getBounds();
    map.dragging.disable();
  }

  function onHandleDrag(e) {
    if (!activeHandle || !initialBounds) return;
    const currentPos = e.target.getLatLng();

    if (activeHandle.handleType === 'rotate') {
      const center = initialBounds.getCenter();
      const startAngle = Math.atan2(dragStartPos.lat - center.lat, dragStartPos.lng - center.lng);
      const currentAngle = Math.atan2(currentPos.lat - center.lat, currentPos.lng - center.lng);
      const deltaAngle = (currentAngle - startAngle) * (180 / Math.PI);
      overlayRotation += deltaAngle;
      dragStartPos = currentPos;
      const el = imageOverlay.getElement();
      el.style.transformOrigin = "center center";
      el.style.transform = `rotate(${overlayRotation}deg)`;
      return;
    }
    // existing resizing/moving logic goes here (omitted for brevity)
  }

  function onHandleDragEnd() {
    activeHandle = null;
    dragStartPos = null;
    initialBounds = null;
    map.dragging.enable();
  }

  // Image upload
  imageUpload.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      if (imageOverlay) map.removeLayer(imageOverlay);
      const marinBounds = [[37.8, -123.2], [38.4, -122.3]];
      imageOverlay = L.imageOverlay(ev.target.result, marinBounds, {
        opacity: opacitySlider.value / 100
      }).addTo(map);
      editOverlayBtn.style.display = 'inline-block';
      toggleOverlay.style.display = 'inline-block';
      removeOverlay.style.display = 'inline-block';
      overlayVisible = true;
    };
    reader.readAsDataURL(file);
  });

  opacitySlider.addEventListener('input', e => {
    if (imageOverlay) imageOverlay.setOpacity(e.target.value / 100);
  });

  editOverlayBtn.addEventListener('click', () => {
    isEditingOverlay = !isEditingOverlay;
    if (isEditingOverlay) {
      createOverlayHandles();
    } else {
      removeOverlayHandles();
    }
  });

  toggleOverlay.addEventListener('click', () => {
    if (imageOverlay) {
      if (overlayVisible) {
        map.removeLayer(imageOverlay);
        removeOverlayHandles();
        overlayVisible = false;
      } else {
        imageOverlay.addTo(map);
        if (isEditingOverlay) createOverlayHandles();
        overlayVisible = true;
      }
    }
  });

  removeOverlay.addEventListener('click', () => {
    if (imageOverlay) {
      map.removeLayer(imageOverlay);
      removeOverlayHandles();
      imageOverlay = null;
      isEditingOverlay = false;
      editOverlayBtn.style.display = 'none';
      toggleOverlay.style.display = 'none';
      removeOverlay.style.display = 'none';
    }
  });

  // Drawing
  function handleMapClick(e) {
    if (!isDrawing || isEditingOverlay) return;
    const lat = e.latlng.lat;
    const lng = e.latlng.lng;
    currentPolygonPoints.push([lat, lng]);
    const marker = L.circleMarker([lat, lng], {
      color: '#ff6b6b', fillColor: '#ff6b6b', fillOpacity: 1, radius: 5
    }).addTo(map);
    tempMarkers.push(marker);
    finishBtn.disabled = currentPolygonPoints.length < 3;
  }
  map.on('click', handleMapClick);

  drawBtn.addEventListener('click', () => {
    isDrawing = !isDrawing;
    if (isDrawing) {
      currentPolygonPoints = [];
      drawBtn.textContent = 'â¸ï¸ Stop Drawing';
    } else {
      drawBtn.textContent = 'ğŸ¨ Start Drawing';
    }
  });

  finishBtn.addEventListener('click', () => {
    if (currentPolygonPoints.length >= 3) {
      const polygon = L.polygon(currentPolygonPoints, {
        color: '#667eea', fillColor: '#667eea', fillOpacity: 0.3, weight: 3
      }).addTo(map);
      completedPolygonLayers.push(polygon);
      allPolygons.push([...currentPolygonPoints]);
      tempMarkers.forEach(m => map.removeLayer(m));
      tempMarkers = [];
      currentPolygonPoints = [];
      finishBtn.disabled = true;
      exportBtn.disabled = false;
    }
  });

  clearBtn.addEventListener('click', () => {
    completedPolygonLayers.forEach(l => map.removeLayer(l));
    completedPolygonLayers = [];
    tempMarkers.forEach(m => map.removeLayer(m));
    tempMarkers = [];
    allPolygons = [];
    currentPolygonPoints = [];
    isDrawing = false;
    drawBtn.textContent = 'ğŸ¨ Start Drawing';
    finishBtn.disabled = true;
    exportBtn.disabled = true;
    kmlOutput.value = '';
  });

  // Export GeoJSON (Y,X format)
  exportBtn.addEventListener('click', () => {
    if (allPolygons.length === 0) return;
    const geojson = {
      type: "FeatureCollection",
      features: allPolygons.map((polygon, index) => ({
        type: "Feature",
        properties: { name: `Polygon ${index + 1}` },
        geometry: {
          type: "Polygon",
          coordinates: [[
            ...polygon.map(pt => [pt[0], pt[1]]), // Y,X
            [polygon[0][0], polygon[0][1]]
          ]]
        }
      }))
    };
    kmlOutput.value = JSON.stringify(geojson, null, 2);
    kmlOutput.select();
  });
</script>
</body>
</html>
